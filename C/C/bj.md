#####第一章 概述

使用数据结构的三个原因是：
1、效率：数据结构组织数据的方式使得算法变得更加高效
2、抽象：数据结构使我们以一种更加容易理解的方式去看待数据，为解决问题提供了一层抽象概念
3、重用性：模块化且上下文无关的

使用算法的三个原因是：
1、效率：人们已经找到了许多高效的方法来解决问题
2、抽象：许多看似复杂的问题都可以用已存在的著名算法来简化
3、重用性：能在很多不同场景下重用

算法设计的一般方法：
按照算法采用的方法和思路给它们分类
随机法：依赖于随机数的统计特性。例子是快速排序

分治法：分解，将数据分解为更小，更容易管理的部分。求解，对每个分解出的部分进行处理。合并，将每部分处理的结果合并。例子是归并排序

动态规划：与分治法类似，但子问题之间并不是独立的，可能是有关系的

贪心法：在求解问题时总能做出在当前的最佳选择。不是从整体最优上考虑，而仅仅是在某种意义上的局部最优解。例子是霍夫曼编码

近似法：并不计算出最优解，只计算出“差不多好”的解。解决那些计算成本很高但又不能放弃的问题。例子是推销员问题

#####第二章  指针操作
指针：一个指针其实只是一个变量，它存储数据在内存中的地址。
结构：结构不允许包含自身的实例，但可以包含指向自身实例的指针
数组：a[i] = *(a+i)
范型指针（void指针）：void* 可以通过void指针存储和检索任何类型的数据
指针的类型转换：a为A类型,b为B类型; a=(A *)b;
函数指针：函数名和*用括号括起来，指向可执行代码段的信息块 int(*match)(int *value1,int *value2)
问与答：有三四个关于本章内容的问答题，类似于面试题，加强了印象，非常好，但问题还算能答上来，描述有点多，就不记录了，可以去看看书。

#####第三章 递归
######基本递归
用阶乘来介绍基本递归：F(n)=nF(n-1)  当n>1; F(n)=1 当n=0,n=1;
然后介绍递归的运行流程，C中函数的执行方式，C在内存中的组织方式
可执行程序由4个区域组成：
代码段：程序运行时所执行的机器指令
静态数据区：在程序生命周期内一直持久的数据，比如全局变量和静态局部变量。
堆：程序运行时动态分配的存储空间
栈：函数调用的信息。

######尾递归
一个函数中所有递归形式的调用都出现在函数的末尾
递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分
同样用阶乘来介绍尾递归：F(n,a)=F(n-1,na) 当n>1; F(n,a)=a 当n=0,n=1;
就是多了第二个参数a（默认为1）,a记录当前值，维护递归层次的深度，避免了每次还需要将返回值再乘以n

######问与答：
1.归并排序用递归的实现：T(n)=2T(n/2)+n 当n>1; T(n)=1 当n=1;
要注意的是判断条件要对
2.用尾递归求解整数质因子：F(n,P)=F(n/i,PUi) 当n不为素数; F(n,P)=PUn 当n为素数;
i为n的最小质因子，P是结果集合
3.当递归的终止条件有误，永远无法满足时，会出现什么情况
栈的增长会超过可接受的值，程序会因为栈溢出而终止运行
...

#####第四章 算法分析
最坏情况分析：告诉我们算法性能的上限，而最好情况都是1次。
讲了下O表示法的简单规则：常数项为O(1)，忽略常量因子，两个运行时间函数加法运算取最大值，乘法结果不变
因为在函数运算次数逐渐变大的时候，这些条件占据整个运行时间的比例会越来越大，直至小的条件占比几乎被忽略
然后介绍了如何计算算法复杂度：按照算法的步骤归纳成公式，最后用O表示法简化
然后分析了下插入排序，得出插入排序的算法复杂度为O(n²)

问与答就是几个计算时间复杂度的题

######相关扩展：
表示算法性能的其他表示法：
O表示法：描述的是在一定条件约束下函数的上限值
Ω表示法：描述的是在一定的条件约束下函数的下限值
θ表示法：描述函数的区间值
W表示法：类似Ω表示法，只是更精确
NP完全问题：
没有已知的求解多项式时间的算法，但也无法证明此多项式不存在，这类问题称为NP完全问题。
很多有用且看似困难的问题都归为此类，一直是计算机科学领域令人困惑和烦恼的问题。

#####第五章 链表
######单链表：
简称为链表，由各个元素之间通过一个指针彼此链接起来而组成。每个元素包含数据成员、next指针，指向后面的元素。
单链表只能从头到尾以一个方向进行遍历。
list文件给出了单链表的抽象数据类型定义

**链表的应用：管理页帧**
frames文件是使用链表管理页帧的例子
在一些支持虚拟内存的系统中，用链表来管理页帧是非常好的办法，因为页帧的分配将涉及频繁的插入和删除操作，而且这些操作都发生在链表头
虚拟内存：一种地址空间的映射机制，它允许进程不必完全加载到物理内存（系统的实际内存）中也可以运行。优点是进程可以使用比物理内存大得多的空间，多个进程能够共享系统的内存以并发的方式执行。
而运行虚拟内存下的进程需要处理虚拟地址，必须由操作系统做转换，每一个进程都有自己的页表，将虚拟地址空间中的页映射到物理内存中的页帧上。

对于开发来说可能用处不大，不过可以更好的理解链表的使用

######双向链表：
链表元素之间由两个指针链接。每个元素包含数据成员、next指针、prev指针，指向前驱元素。

双向链表书上没有例子与应用，直接看看源码dlist文件吧

######循环链表：
有尾部元素的链表，可以是单向的或双向的

**循环链表的应用：第二次机会页面置换法**
第二次机会页面置换法，也称时钟算法，是最近最少使用算法（也称为LRU页面替换法，Least Recenty Used）
跟随上面,是系统管理内存页帧分配的例子，解决空闲页面链表为空时，系统为其分配新的页帧。
大概就是当需要某个页帧时，系统遍历链表，找到上次遍历没有被系统访问过的页面，因为最后要回到遍历开始的页面，所以循环链表最适合。
作者花了一整页篇幅来讲解，但我认为对于开发来说可能用处不大，建议看看源码即可

######问与答：
1、数组与链表的使用情况：
进行频繁的插入和删除时，链表更适合，而数组的元素是连续排列的，更适合通过索引查找
2、链表的增删改查与数组相比有何差异？
的确，链表除了销毁操作之外，其他操作都是O(1)，但是都需要一个想要操作的元素指针，而得到该指针的代价是很高的，需要遍历链表
插入本身复杂度是O(1)，但是访问特定位置的元素复杂度是O(n)
3、为什么单链表和循环链表不能指定移除该元素，而是该元素下一个元素？
因为没有指向前驱结点的指针，所以找不到前驱结点来指向被移除元素的后继结点。
...


#####第六章 栈和队列
######栈
后进先出，羽毛球筒
作者使用链表实现栈的，调用的链表的实现方法

######队列
先进先出，排队
作者也是使用链表来实现队列的，调用的队列的实现方法

作者用事件驱动来举例队列的作用，因为计算机的应用主要遵循的是实时发生的顺序来执行，需要有序地存储和管理事件。
当告知应用程序有事件将进行处理时，将一个事件入队，当应用程序认为是时候处理一个事件时，将一个事件出队

######问与答：
1、从一个队列中删除一些元素，剩下的按顺序留在队列中，用队列和链表如何处理
队列：从头开始出队，不删除的出队后再入队
链表：遍历，遍历到元素后用list_rem_next函数删除即可


#####第七章 集合
集合是不同对象的无序聚集。成员是无序的，每个成员都只在集合中出现一次
是数学中集合的概念，有子集，并集，空集等等，操作也是交集，并集，差集等
作者也是使用链表来实现的，所以很多函数需要遍历，性能适合小型到中等规模的集合数据

**集合的应用：集合覆盖**
在一群选手中挑选人员组建出一支队伍，每名选手都有特定的技能组合。目标是组建出人数最少，但所有技能都有的队伍。
技能集合S={a,b,c,d,e}   
选手集合P={A1，A2，A3，A4}
组合集合为：A1={a,b} A2={c,d,e} A3={a,b,c,d} A4={a}
最佳集合应为C={A1，A2}
但算法的结果为C={A3，A2,A1}


是一种优化求解问题
每次开始都在subsets中找出能够覆盖到members的最大交集，然后加到covering中，所以有可能解会有小小的多余，是一种近似最优解
int cover(Set *members,Set *subsets,Set *covering);
members为S，subsets为P中的子集如A1， covering为C


#####第八章 哈希表
散列表，通过一个哈希函数，在所有可能的键与槽位之间建立一张映射表。

######链式哈希表
由一组链表构成，每个链表都可以看做一个桶，所有的元素通过散列的方式放到具体的不同的桶中

**解决冲突**
两个键散列到一个相同的槽位时，两个键之间会产生冲突
链式哈希表就直接将元素放入桶中，但桶有可能越来越大
一个好的哈希函数会尽可能做到均匀散列
h(k) = m 一般k为整型

**转换键的方法：**
取余法：计算k除以m的所得到的余数，将k映射到m槽位
h(k)=k mod m

乘法：将整型键k乘以一个常数A(0<A<1)，取结果的小数部分，然后乘以m取结果的整数部分。

**链式哈希表的应用：符号表**
在编译器中用来维护程序中出现的符号信息。
编译器在翻译时，为了能够更加有效地管理程序中的符号信息，使用符号表

######开地址哈希表
元素存放在表本身，用于依赖于固定大小表的应用

**解决冲突**
探查这个表，直到找到一个可以放置元素的槽
探查槽位的哈希函数定义为：h(k,i)=x
k是键，i是探查的次数，x是得到的哈希编码

**线性探查**
用哈希函数定位到某一数值后探查表中连续的槽位
h(k,i) = (h(k)+i) mod m
**双散列**
通过计算两个辅助哈希函数哈希编码的和来得到哈希编码
h(k,i) = (h1(k)+ih2(k)) mod m 
h1与h2为两个辅助哈希函数，能够在表中探查并产生较好的元素分布

######问与答：
1、链式哈希表的最坏性能？如何保证不会发生？
所有元素全部散列在一个桶中时，性能最差
选择一个好的哈希函数😂
2、开地址哈希表的最坏性能？如何保证不会发生？
表已经满了，而且要查找的元素不在此表中，性能最差
不要让元素的个数超过表容量的80%


#####第九章 树
树的基本概念与前几本书都没有什么差别，所以基本术语就不再记录了
该书有好多易懂的图，看图一眼就懂了

######树的周游算法
先序遍历,中序遍历,后序遍历,层序遍历

######树的平衡
在结点加入下一层之前必须保证本层结点满额，保证树的高度尽可能短
如果一棵平衡树最后一层的所有叶子结点都在最靠左边的位置上，则称树为左平衡的。

这本书也用表达式的处理来讲解二叉树

######二叉搜索树
由二叉树组成的专用于查找和搜索目的的一种数据结构。
从根结点开始一层一层往下查找，当遇到一个比目标结点值大的结点时，顺着该结点的左子树继续查找；如果遇到的结点值小于目标结点，则顺着该结点的右子树继续查找。

但是，只有当二叉搜索树保持平衡时查找效率才会高，所以出现了AVL树和红黑树。

######AVL树
一种特殊类型的二叉树，每个结点都保存一份额外的信息：结点的平衡因子（右子树高度减去左子树高度的结果）
一棵子树的根结点的平衡因子就代表该子树的平衡性
如果任何平衡因子变为了+-2，就必须重新平衡这棵树，称为旋转。

**AVL树的旋转**
旋转用来重新平衡AVL树的某个部分，旋转过后，旋转子树中的所有结点的平衡因子都为+1，-1，0
有四种：LL、LR、RR、RL（right，left）
这四种分别表示当插入的元素x在A树的左子树的左子树上；在A树的左子树的右子树上；在A树的右子树的右子树上；在A树的右子树的左子树上，平衡这棵树要进行的操作。

######问与答：
1、一些树除了有从父结点指向子结点的正常指针外，还有从子结点指向父结点的指针，有的兄弟结点之间也有相互关联的指针。为什么？
维护附加的指针为遍历树时提供了更加灵活的方式。子结点指向父结点的指针可以自下而上遍历，兄弟结点之间的指针可以不必访问父结点。

2、在bitree_rem_left与bitree_rem_right中，为什么要采用后序遍历的方式来移除子树？
因为子树必须在其父结点之前就被全部移除

3、在二叉搜索树中我们如何找到最小的结点？在最坏的情况下，在非平衡和平衡二叉搜索树中该操作的时间复杂度是多少？如何在二叉搜索树中找到最大的结点？时间复杂度？
二叉搜索树中最小结点是最左边的那个叶子结点。从根结点开始通过左指针逐层下降，直到边缘。最坏情况为当只有一个单独的左分支时，O(n)。平均为O(lgn)。
最大结点是最右边的那个叶子结点。时间复杂度一样。

4、何时应该选择使用分支因子相对较大的树而不是二叉树呢？
对于给定的结点个数，分支因子大能够保持这棵树的高度较低，也就能使树能够保持相对的平衡性。
在对树的高度敏感的应用中，采用分支因子较大的树。在内存中的性能并没有显著提升，但在速度相对较慢的辅助存储空间（闪存）内执行查找操作时，在性能上有明显的区别。
二叉树通常用于内存中查找操作。

5、在一棵二叉搜索树中，某结点的后继结点是指x之后的下一个最大结点。
如24、39、41、55、87、92中，41的后继是55。如何在二叉搜索树中找到某个结点的后继结点？时间复杂度？
首先要定位到x。然后移动到x的右子结点，从这个结点开始不断通过左指针访问下层的左子结点，直到到达分支的边缘。这条分支边缘位置上的结点即后继结点。为O(lgn)。

6、在二叉搜索树中插入一个结点，按照一条特定的路径找到一个合适的位置作为插入点。随着越来越多的结点插入树中，最终，某个值将不再适合插入某区域中了。所以树会失去平衡然后必须进行旋转操作。
总之一个原则：左子树结点必须小于该结点，右子树结点必须大于该结点。


#####第十章 堆和优先队列
堆：一棵二叉树，分为大顶堆和小顶堆。左平衡的，从左至右增长。
大顶堆根结点是树中最大的结点，每个子结点存储的值比父结点的值小。
小顶堆根结点是树中最小的结点，每个子结点存储的值比父结点的值大。

优先队列：将数据按照优先级顺序排列。
作者是用一个局部有序的堆来实现的。

######优先队列的例子：包裹分拣
快递公司根据包裹的紧急程度、服务类型，将快递按照优先级排序。

######问与答：
1、每次向一个堆中插入元素都要重新排序，时间复杂度有点高，是否有其他办法构建一个堆，降低复杂度？
避免重复调用insert函数，不断调整一个结点数组，将结点往树的根部递推。首先调整(n/2)-1的树，再调整(n/2)-2的树，直到调整根结点处于0的树

2、左平衡二叉树特别适合存储于数组中，为什么不是对所有的二叉树都成立？
对于n是树中结点的个数，因为在位置0和n-1之间肯定会用到结点，空间利用率高，如果出现个右结点，数组中位置会出现空

3、如果用优先队列来存放已经设定好顺序的任务，如果系统不断处理大量高优先级的任务，可能会产生什么问题？
低优先级的元素可能永远都没机会排到队列的顶部，导致“饿死”。
采取机制提高任务等级，比如随着任务在队列中待的时间变得越来越长增加。

#####第十一章 图
图由顶点和边组成，顶点代表对象，边建立起对象之间的关系ADG
G=(V,E)，V代表顶点的集合，E代表关系的集合

最常用表示图的方法是采用邻接表表示有向图。
广度优先搜索，广度优先树。
深度优先搜索，深度优先树。

######图的例子
1、计算网络跳数
确定在互联网中从一个结点到另一个结点的最佳路径。采用广度优先搜索来帮助确定结点间的最小跳数。

2、拓扑排序
根据各种事件间的依赖关系来确定一种可接受的执行顺序。
比如执行完a才能执行b，执行完b才能执行c
通过对事件进行深度优先搜索，确定出一种可接受的顺序。


######问与答：
1、本章的图中，为什么采用链表来实现邻接表结构链表，而邻接表本身却采用集合的方式来实现？
用链表，能够动态的扩展和收缩。用集合，因为邻接表包含的顶点是无序的，针对邻接表的主要操作非常适合。
这里邻接表结构链表的主要操作时找出特定顶点的邻接表，链表比集合更适合。
先说数据类型的优点，然后是否适合当前问题即可。

2、假设用图对互联网建模，我们确定图包含一个关结点，会有什么影响？
关结点代表一个单点故障源，如果位于关结点的系统失效，其他结点上的系统就无法互相通信了。因此在设计时就要保证没有关结点，通过放置冗余结点来解决。

3、用图对航线结构进行建模...？
广度优先搜索

4、模拟十字路口的交通灯系统？
有向图
































