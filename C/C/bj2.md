#####第12章 排序和搜索
通常有两种排序方法：升序排列和降序排列
排序算法分为两大类：比较排序和线性时间排序
比较排序依赖于比较和交换，线性时间排序依赖于数据集合中的某些特征。

######插入排序
每次从无序数据集中取出一个元素，扫描已排好序的数据集，并将它插入有序集合合适的位置上。
但并不需要额外的存储空间。
处理大型数据集时并不高效。在决定将元素插入之前，需要将被插入元素和有序数据集中其他元素进行比较，会随着数据集的增大而增加额外的开销。
优点是只需要对有序数据集最多进行一次遍历，而不需要完整地运行算法。在增量排序中非常高效。
复杂度 O(n²)

######快速排序
不断地将无序元素集递归分割，直到所有的分区都只包含单个元素。
一种分治排序算法，比较排序的一种。也不需要额外的存储空间。
处理中到大型数据集的一个比较好的选择，解决一般问题的最佳算法
复杂度最坏为O(n²) 平均为O(nlgn)

分：设定一个分割值将数据分为两部分，这点很关键，影响到性能。
治：分别在两部分用递归继续调用
合：对分割部分排序直至完成

######归并排序
将一个无序元素集分割成许多个只包含一个元素的集，然后不断地将这些小集合并，直到成为一个新的大有序数据集。
一种分治排序算法，比较排序的一种。但是需要额外的存储空间。
与快速排序最大的不同在于它的归并过程。将两个有序的数据集合并成一个有序的数据集，并且合并过程不能在无序数据集本身中进行，要有两倍于无序数据集的空间来运行算法。
对于海量数据处理还是很有价值的，因为能够按预期将数据集分开，成为更加可管理的数据，然后合并，并不需要一次存储所有的数据。
复杂度平均为O(nlgn)

######计数排序
计算一个集合中元素出现的次数来确定集合如何排列
一种线性排序
只能用于整型或者那些可以用整型来表示的数据集合，还需要知道集合中最大整数的值用来分配空间。
优点是速度快，稳定。
时间复杂度为O(n+k) k为data中最大整数加1

######基数排序
将数据按位分开，并从数据的最低有效位到最高有效位进行比较，依次排序，（从个位数排序，然后排序十位数...）
一种线性排序
不局限于整型，只要能把元素分割成整型即可。
时间复杂度为O(pn+pk) k为基数（10进制），p为位的个数（100就是3位）






































